<h2 id="pour-aller-plus-loin">Pour aller plus loin</h2><p>NodeAtlas offre également tout un système de fonctionnalités de développement et de packaging à travers son sytème de configuration. Voyons cela.</p><h3 id="gerer-le-routage-url-rewriting">Gérer le routage (Url Rewriting)</h3><p>Bien que vous puissiez paramétrer des URLs statiques, vous pouvez également paramétrer une écoute d'URLs dynamiques !</p><h4 id="param-tres">Paramètres</h4><p>Il est possible de récupérer des paramètres de l'URL pour afficher un contenu différent en fonctions de leurs contenus.</p><p>Avec la configuration suivante :</p><pre><code class="lang-json">{
    "routes": {
        "/liste-des-membres/:member/:action/": {
            "view": "members.htm",
            "controller": "members.js"
        },
        "/liste-des-membres/:member/:action": {
            "view": "members.htm",
            "controller": "members.js"
        },
        "/liste-des-membres/:member/": {
            "view": "members.htm",
            "controller": "members.js"
        },
        "/liste-des-membres/:member": {
            "view": "members.htm",
            "controller": "members.js"
        },
        "/liste-des-membres/": {
            "view": "members.htm",
            "controller": "members.js"
        },
        "/liste-des-membres": {
            "view": "members.htm",
            "controller": "members.js"
        },
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>vous pourrez accéder à :</p><ul>
<li><em><a href="http://localhost/">http://localhost/</a></em></li>
<li><em><a href="http://localhost/liste-des-membres">http://localhost/liste-des-membres</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/">http://localhost/liste-des-membres/</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/toto/">http://localhost/liste-des-membres/toto/</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/bob-eponge99">http://localhost/liste-des-membres/bob-eponge99</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/node-atlas/show/">http://localhost/liste-des-membres/node-atlas/show/</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/etc/lolol">http://localhost/liste-des-membres/etc/lolol</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/?example=test">http://localhost/liste-des-membres/?example=test</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/etc?example=test">http://localhost/liste-des-membres/etc?example=test</a></em> (en POST avec <code>test=This+is+a+test</code>)</li>
</ul><p>et récupérer les valeurs de <code>:member</code>, <code>:action</code>, <code>example</code> et <code>test</code> dans le <code>changeVariations</code> (common et specific).</p><pre><code class="lang-js">exports.changeVariations = function (next, locals, request, response) {

    console.log("param request:", request.params.member);
    // $ undefined, 'toto', 'bob-eponge99', 'node-atlas' or 'etc'.
    console.log("param locals:", locals.params.member);
    // $ undefined, 'toto', 'bob-eponge99', 'node-atlas' or 'etc'.

    console.log("param request", request.params.action);
    // $ undefined, 'show' or 'lolol'.
    console.log("param locals", locals.params.action);
    // $ undefined, 'show' or 'lolol'.

    console.log("query request", request.query.example);
    // $ undefined or 'test'
    console.log("query locals", locals.query.example);
    // $ undefined or 'test'

    console.log("body request", request.body.test);
    // $ undefined or 'This is a test'.
    console.log("body locals", locals.body.test);
    // $ undefined or 'This is a test'.

    next();
};
</code></pre><h3 id="parametres-avances">Paramètres avancés</h3><p>Nous voyons que nous utilisons une configuration identique pour trois routes dans l'exemple précédent. Vous pouvez également vous aider d'expressions régulières pour définir ce qui peut varier pour accéder à votre URL ou préciser quels sont les paramètres valides dans l'URL. Ce sytème est simplifié étant donné que beaucoup de caractère ne se trouve pas dans l'url. Il n'est donc pas nécéssaire par exemple d'échaper les <code>/</code> par exemple.</p><p>Avec la configuration suivante :</p><pre><code class="lang-json">{
    "routes": {
        "/liste-des-membres/?(:member([-a-zA-Z0-9]+)/?(:action(afficher|editer)/?)?)?": {
            "view": "members.htm"
        },
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>vous pourrez accéder à :</p><ul>
<li><em><a href="http://localhost/">http://localhost/</a></em></li>
<li><em><a href="http://localhost/liste-des-membres">http://localhost/liste-des-membres</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/">http://localhost/liste-des-membres/</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/toto/">http://localhost/liste-des-membres/toto/</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/bob-eponge99">http://localhost/liste-des-membres/bob-eponge99</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/node-atlas/show/">http://localhost/liste-des-membres/node-atlas/show/</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/?example=test">http://localhost/liste-des-membres/?example=test</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/etc?example=test">http://localhost/liste-des-membres/etc?example=test</a></em> (en POST avec <code>test=This+is+a+test</code>)</li>
</ul><p>et récupérer les valeurs de <code>:member</code>, <code>:action</code>, <code>example</code> et <code>test</code> dans une vue.</p><pre><code class="lang-html"><!DOCTYPE html>
<html lang="fr-fr">
  <head>
    <meta charset="utf-8">
    <title>URL Rewriting Test</title>
  </head>
  <body>
    Member: <strong><?- params.member ?></strong><br>
    Action: <strong><?- params.action ?></strong><br>
    Example: <strong><?- query.example ?></strong><br>
    Test: <strong><?- body.test ?></strong>
  </body>
</html>
</code></pre><p>vous ne pourrez pas accéder à :</p><ul>
<li><em><a href="http://localhost/liste-des-membres/etc/lolol">http://localhost/liste-des-membres/etc/lolol</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/`toto_16`/afficher/">http://localhost/liste-des-membres/`toto_16`/afficher/</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/toto/`supprimer`/">http://localhost/liste-des-membres/toto/`supprimer`/</a></em></li>
</ul><h4 id="expressions-r-guli-res">Expressions Régulières</h4><p>Vous pouvez également activer les expressions régulières pour un chemin précis avec <code>regExp</code>. Si celui-ci vaut <code>true</code>, le précédent mode ne fonctionne plus et vous passez en mode Expression Régulière. Si <code>regExp</code> est une chaine de caractère, celle-ci fait office de flag (g, i, m ou y).</p><p>Voyez la configuration suivante :</p><pre><code class="lang-js">{
    "routes": {
        "/liste-des-membres/([-a-z0-9]+)/?": {
            "view": "members.htm",
            "regExp": "i"
        },
        "/liste-des-membres/?": {
            "view": "members.htm",
            "regExp": true
        },
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>vous pourrez accéder à :</p><ul>
<li><em><a href="http://localhost/">http://localhost/</a></em></li>
<li><em><a href="http://localhost/liste-des-membres/">http://localhost/liste-des-membres/</a></em> <em>(ou <em><a href="https://localhost/liste-des-membres">https://localhost/liste-des-membres</a></em>)</em></li>
<li><em><a href="http://localhost/liste-des-membres/toto/">http://localhost/liste-des-membres/toto/</a></em> <em>(ou <em><a href="https://localhost/liste-des-membres/toto">https://localhost/liste-des-membres/toto</a></em>)</em></li>
<li><em><a href="http://localhost/liste-des-membres/bob-eponge99/">http://localhost/liste-des-membres/bob-eponge99/</a></em> <em>(ou <em><a href="https://localhost/liste-des-membres/bob-eponge99">https://localhost/liste-des-membres/bob-eponge99</a></em>)</em></li>
<li><em><a href="http://localhost/liste-des-membres/node-atlas/">http://localhost/liste-des-membres/node-atlas/</a></em> <em>(ou <em><a href="https://localhost/liste-des-membres/node-atlas">https://localhost/liste-des-membres/node-atlas</a></em>)</em></li>
<li><em><a href="http://localhost/liste-des-membres/etc/">http://localhost/liste-des-membres/etc/</a></em> <em>(ou <em><a href="https://localhost/liste-des-membres/etc">https://localhost/liste-des-membres/etc</a></em>)</em></li>
</ul><p>et récupérer les valeurs de <code>([-a-z0-9]+)</code> dans le <code>changeVariations</code> (common et specific).</p><pre><code class="lang-js">exports.changeVariation = function (next, locals) {

    if (locals.params && locals.params[0]) { locals.params.member = locals.params[0]; }
    // locals.params[1] pour le deuxième match, etc...

    console.log(locals.params.member);
    // $ 'toto', 'bob-eponge99', 'node-atlas' ou 'etc'.

    next();
}
</code></pre><p>Les règles de création d'url dynamique avec <code>regExp</code> sont celles des <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScripts/Reference/Global_Objects/RegExp">RegExp JavaScript</a>.</p><h3 id="gerer-les-pages-inexistantes">Gérer les pages inexistantes</h3><h4 id="-couter-toutes-les-urls-m-me-les-adresses-du-dossier-assetsrelativepath-">Écouter toutes les urls, même les adresses du dossier <code>assetsRelativePath</code></h4><p>Pour afficher une page personnalisée quand une ressource n'est pas trouvée il faut :</p><ol>
<li>Préparer une page 404.</li>
<li>Remplir le paramètre <code>pageNotFound</code> avec comme <code>value</code> la <code>key</code> de la page 404 préparée.</li>
</ol><p>Voyez l'exemple ci-dessous :</p><pre><code class="lang-json">{
    "pageNotFound": "/pages-inexistantes/",
    "routes": {
        "/liste-des-membres/": {
            "view": "members.htm"
        },
        "/": {
            "view": "index.htm"
        },
        "/pages-inexistantes/": {
            "view": "error.htm",
            "statusCode": 404
        }
    }
}
</code></pre><p>vous pourrez accéder à :</p><ul>
<li><em><a href="http://localhost/cette-page-n-existe-pas.html">http://localhost/cette-page-n-existe-pas.html</a></em></li>
<li><em><a href="http://localhost/elle/non/plus/">http://localhost/elle/non/plus/</a></em></li>
<li><em><a href="http://localhost/etc">http://localhost/etc</a></em></li>
</ul><h4 id="page-d-erreur-localis-e">Page d'erreur localisée</h4><p>Il vous suffit de créer une nouvelle route finissant par <code>*</code> dans la langue souhaitée.</p><p>Voyez l'exemple ci-dessous :</p><pre><code class="lang-json">{
    "pageNotFound": "/pages-inexistantes/",
    "languageCode": "fr-fr",
    "routes": {
        "/liste-des-membres/": {
            "view": "members.htm",
            "variation": "members.json"
        },
        "/": {
            "view": "index.htm",
            "variation": "index.json"
        },
        "/pages-inexistantes/": {
            "view": "error.htm",
            "variation": "error.json",
            "statusCode": 404
        },
        "/english/list-of-members/": {
            "view": "members.htm",
            "languageCode": "en-gb",
            "variation": "members.json"
        },
        "/english/": {
            "view": "index.htm",
            "languageCode": "en-gb",
            "variation": "index.json"
        },
        "/english/*": {
            "view": "error.htm",
            "languageCode": "en-gb",
            "variation": "error.json",
            "statusCode": 404
        }
    }
}
</code></pre><h3 id="injecter-des-routes-dynamiquement">Injecter des routes dynamiquement</h3><p>Nous avons pu voir qu'avec <code>setRoutes</code> il était possible d'injecter dynamiquement des routes. Cependant, l'injection de route ne se fait qu'à la fin car <code>NA.webconfig.routes</code> est un objet. Il n'y a donc pas de moyen d'ordonner les routes, ce qui est génant car les routes sont résolu dans l'ordre dans lesquels elles ont été injectées.</p><p>Nous allons résoudre ça en changeant la manière de créer les routes de <code>routes: { <key>: { ... } }</code> à <code>routes: [{ "key": <key>, ... }]</code>.</p><p>Voici l'ensemble de fichier suivant :</p><pre><code>├─ controllers/
│  └─ common.js
├─ views/
│  ├─ index.htm
│  ├─ content.htm
│  └─ error.htm
└─ webconfig.json
</code></pre><p>Avec le <code>webconfig.json</code> initialement comme ceci avec <code>routes: <Object></code> :</p><pre><code class="lang-json">{
    "controller": "common.js",
    "routes": {
        "/doc/index.html": {
            "view": "index.htm"
        },
        "/doc/*": {
            "view": "error.htm",
            "statusCode": 404
        }
    }
}
</code></pre><p>se transformant en cela avec <code>routes: <Array></code> :</p><pre><code class="lang-json">{
    "controller": "common.js",
    "routes": [{
        "url": "/doc/index.html
        "view": "index.htm"
    }, {
        "url": "/doc/*",
        "view": "error.htm",
        "statusCode": 404
    }]
}
</code></pre><p>Avec le fichier « common.js » nous pouvons maintenant injecter les routes à des positions précise. Nous allons les ajoutés au début.</p><pre><code class="lang-json">// On intervient au niveau des routes pendant qu'elles sont ajoutées.
// Ce code sera exécuté au lancement de NodeAtlas.
exports.setRoutes = function (next) {

    // On récupère l'instance de NodeAtlas en cours.
    var NA = this,

        // Et nous récupérons les routes en provenance du webconfig...
        route = NA.webconfig.routes;

    // ...pour ajouter la route "/content.html" au débuts de nos routes.
    route.unshift({
        "url": "/doc/content.html",
        "view": "content.htm"
    });

    // On redonne la main à NodeAtlas pour la suite.
    next();
};
</code></pre><p>De cette manière l'adresse <code>http://localhost/doc/content.html</code> renverra la vue <code>content.htm</code> et non la vue <code>error.htm</code> en 404.</p><h3 id="gerer-les-redirections">Gérer les redirections</h3><p>Pour aller à une autre adresse (redirection 301 ou 302) quand vous arrivez à une url il faut utiliser le paramètre <code>redirect</code>.</p><p><em>Note : si vous ne précisez pas un <code>statusCode</code>, la redirection ne se fera pas. Le <code>statusCode</code> est obligatoire.</em></p><h4 id="en-statique">En statique</h4><p>Voyez l'exemple ci-dessous :</p><pre><code class="lang-json">{
    "routes": {
        "/liste-des-membres/": {
            "view": "members.htm"
        },
        "/liste-des-membres": {
            "redirect": "/liste-des-membres/",
            "statusCode": 301
        },
        "/aller-sur-node-atlas/": {
            "redirect": "https://node-atlas.js.org/",
            "statusCode": 302
        },
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>Vous serez redirigé :</p><ul>
<li>sur <code>http://localhost/liste-des-membres/</code> quand vous accéderez à <code>http://localhost/liste-des-membres</code> avec une entête <em>redirection permanente</em>.</li>
<li>sur <code>https://node-atlas.js.org/</code> quand vous accéderez à <code>http://localhost/aller-sur-node-atlas/</code> avec une entête <em>redirection temporaire</em>.</li>
</ul><h4 id="en-dynamique">En dynamique</h4><p>Voyez l'exemple ci-dessous :</p><pre><code class="lang-json">{
    "routes": {
        "/liste-des-membres/:member/": {
            "view": "members.htm"
        },
        "/liste-des-membres/:member": {
            "redirect": "/liste-des-membres/:member/",
            "statusCode": 301
        },
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>Vous serez redirigé sur <code>http://localhost/liste-des-membres/haeresis/</code> quand vous accéderez à <code>http://localhost/liste-des-membres/haeresis</code> avec une entête <em>redirection permanente</em>.</p><h4 id="avec-expressions-r-guli-res">Avec expressions régulières</h4><p>Voyez l'exemple ci-dessous :</p><pre><code class="lang-js">{
    "routes": {
        "/membres/([-a-z0-9]+)/": {
            "view": "members.htm",
            "regExp": true
        },
        "/liste-des-membres/([-a-z0-9]+)/": {
            "redirect": "/membres/$0/",
            "statusCode": 301,
            "regExp": true
        },
        "/liste-des-membres/": {
            "view": "members.htm"
        },
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>Vous serez redirigé sur <code>http://localhost/membres/haeresis/</code> quand vous accéderez à <code>http://localhost/liste-des-membres/haeresis/</code> avec une entête <em>redirection permanente</em>.</p><p>Pour le second <em>match</em> utilisez $1, pour le troisième $2, etc.</p><h3 id="gerer-les-headers-de-page">Gérer les Headers de page</h3><p>Par défaut, les Headers envoyé par NodeAtlas sont les suivants : <code>Content-Type:text/html; charset=utf-8</code> avec un <code>statusCode</code> à 200.</p><p>Il est tout à fait possible de modifier ses valeurs pour une entrée de route pour des APIs local au site.</p><pre><code class="lang-json">{
    "mimeType": "application/json",
    "charset": "utf-16",
    "routes": {
        "/": {
            "view": "index.htm",
            "mimeType": "text/html"
        },
        "/api/articles": {
            "view": "display-json.htm",
            "controller": "blog/list-of-articles.js",
            "charset": "utf-8",
            "statusCode": 203
        }
    }
}
</code></pre><p>Il est également possible de modifier complètement les Headers, ce qui écrase toutes les autres valeurs de headers (à l'exception du <code>statusCode</code> donc). Mettre une valeur à <code>false</code> retire le Headers précédemment mis en place.</p><pre><code class="lang-json">{
    "headers": {
        "Content-Type": "application/json; charset=utf-8",
        "Access-Control-Allow-Origin": "*"
    },
    "routes": {
        "/api/articles": {
            "view": "display-json.htm",
            "controller": "blog/list-of-articles.js",
            "statusCode": 203,
            "headers": {
                "Access-Control-Allow-Origin": false
            }
        }
    }
}
</code></pre><h3 id="configuration-dynamique">Configuration dynamique</h3><p>Plutôt que d'utiliser plusieurs configurations statique <code>.json</code>, il est tout a fait possible d'utiliser des configurations dynamiques <code>.js</code>. Dans ce cas, ce que votre fichier <code>.js</code> devra retourner avec <code>module.exports</code> sera un objet JSON valide.</p><p>Nous pouvons ainsi aisément remplacer les six fichiers suivants :</p><p><em>webconfig.json</em></p><pre><code class="lang-json">{
    "languageCode": "fr-fr",
    "statics": "statics.fr-fr.json"
    "routes": {
        "/": "index.htm"
    }
}
</code></pre><p><em>webconfig.prod.json</em></p><pre><code class="lang-json">{
    "cache": true,
    "languageCode": "fr-fr",
    "statics": "statics.fr-fr.json"
    "routes": {
        "/": "index.htm"
    }
}
</code></pre><p><em>webconfig.en-us.json</em></p><pre><code class="lang-json">{
    "languageCode": "fr-fr",
    "statics": "statics.fr-fr.json"
    "routes": {
        "/": "index.htm"
    }
}
</code></pre><p><em>webconfig.en-us.prod.json</em></p><pre><code class="lang-json">{
    "cache": true,
    "languageCode": "en-us",
    "statics": "statics.en-us.json"
    "routes": {
        "/": "index.htm"
    }
}
</code></pre><p><em>statics.fr-fr.json</em></p><pre><code class="lang-json">{
    "/variations/": "variations/fr-fr/",
}
</code></pre><p><em>statics.en-us.json</em></p><pre><code class="lang-json">{
    "/variations/": "variations/en-us/",
}
</code></pre><p>par les deux fichiers suivants :</p><p><em>webconfig.json</em></p><pre><code class="lang-json">module.export = (function () {
    var webconfig = {
        "cache": false,
        "languageCode": "fr-fr",
        "statics": "statics.json"
        "routes": {
            "/": "index.htm"
        }
    };

    if (process.env.NODE_ENV === 'production') {
        webconfig["cache"] = true;
    }

    if (process.env.LANG) {
        webconfig["languageCode"] = process.env.LANG;
    }

    return webconfig;
}());
</code></pre><p><em>statics.json</em></p><pre><code class="lang-json">module.export = (function () {
    var NA = this.NA,
        languageCode = NA.webconfig.languageCode

    return {
        "/variations/": "variations/" + languageCode + "/",
    };
}());
</code></pre><p>en supposant les variables d'environnements suivantes pour les quatre environnements suivants :</p><p>Local FR</p><pre><code class="lang-bash">NODE_ENV=DEVELOPMENT
LANG=fr-fr
</code></pre><p>Local EN</p><pre><code class="lang-bash">NODE_ENV=DEVELOPMENT
LANG=en-us
</code></pre><p>Prod FR</p><pre><code class="lang-bash">NODE_ENV=PRODUCTION
LANG=fr-fr
</code></pre><p>Prod EN</p><pre><code class="lang-bash">NODE_ENV=PRODUCTION
LANG=en-us
</code></pre><h3 id="faire-tourner-le-site-en-https">Faire tourner le site en HTTPs</h3><p>Il est très simple de faire tourner une instance de NodeAtlas avec le protocol HTTPs. Pour cela il suffit de créer, par exemple un dossier <code>security</code> dans lequel vous allez placer vos fichiers <code>server.key</code> et <code>server.crt</code> afin d'alimenter le protocol.</p><p>Il ne vous reste plus qu'à utiliser la configuration suivante :</p><pre><code class="lang-json">{
    "httpSecure": true,
    "httpSecureKeyRelativePath": "security/server.key",
    "httpSecureCertificateRelativePath": "security/server.crt",
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>Vous pouvez également, si —comme c'est le cas ici— vos deux fichiers Key et Certificate portent le même nom, utiliser cette configuration :</p><pre><code class="lang-json">{
    "httpSecure": "security/server",
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>Pour finir, il est également possible de seulement laisser la valeur de <code>httpSecure</code> à <code>true</code> pour obtenir un <code>https</code> dans vos chemins comme <code>urlBasePath</code> ou <code>urlBase</code>. Cependant le serveur ce lancera en HTTP, il vous faudra un proxy qui gère pour vous la lecture du certificat.</p><pre><code class="lang-json">{
    "httpSecure": true,
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p><em>Note : en production, si vous redirigez un proxy vers votre instance de NodeAtlas, n'oubliez pas qu'en HTTPs ce n'est pas <code>urlPort: 80</code> mais <code>urlPort: 443</code></em></p><h3 id="minifier-les-css-js">Minifier les CSS / JS</h3><p>Vous pouvez automatiquement générer des fichiers CSS et JS minifiés et offusqués en créant des Bundles en référençant les groupes de fichiers d'entré par leur chemin d'accès et le chemin du fichier de sortie. Vous pouvez bien entendu en faire autant que vous le souhaitez. La génération des fichiers se fait à chaque démarrage de NodeAtlas que ce soit en tant que serveur ou via la commande <code>--generate</code> pour peu qu'un Bundle existe dans le Webconfig.</p><h4 id="cr-er-des-bundles">Créer des Bundles</h4><p>Avec la configuration suivante :</p><pre><code class="lang-json">{
    "bundles": {
        "javascripts": {
            "javascripts/boot.min.js": [
                "javascripts/modernizr.js",
                "javascripts/yepnot.js",
                "javascripts/html5Shiv.js"
            ],
            "javascripts/framework.min.js": [
                "javascripts/jquery.js",
                "javascripts/jquery-ui.js",
                "javascripts/prettify.js",
                "javascripts/prettify/run_prettify.js"
            ],
            "javascripts/common.min.js": [
                "javascripts/components/extended-format-date.js",
                "javascripts/common.js"
            ]
        },
        "stylesheets": {
            "stylesheets/common.min.css": [
                "stylesheets/common.css",
                "stylesheets/common-min780.css",
                "stylesheets/common-min1160.css"
            ]
        }
    },
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>et l'ensemble de fichier suivant :</p><pre><code>├─ assets/
│  ├─ stylesheets/
│  │  ├─ common.css
│  │  ├─ common-min780.css
│  │  └─ common-min1160.css
│  └─ javascripts/
│     ├─ modernizr.js
│     ├─ yepnot.js
│     ├─ html5Shiv.js
│     ├─ jquery.js
│     ├─ jquery-ui.js
│     ├─ prettify.js
│     ├─ prettify/
│     │  └─ run_prettify.js
│     ├─ components/
│     │  └─ extended-format-date.js
│     └─ common.js
├─ views/
│  └─ index.htm
└─ webconfig.json
</code></pre><p>vous obtiendrez les nouveaux fichiers suivant :</p><pre><code>├─ assets/
│  ├─ stylesheets/
│  │  ├─ common.css
│  │  ├─ common-min780.css
│  │  ├─ common-min1160.css
│  │  └─ common.min.css     ⤆ nouveau fichier
│  └─ javascripts/
│     ├─ modernizr.js
│     ├─ yepnot.js
│     ├─ html5Shiv.js
│     ├─ jquery.js
│     ├─ jquery-ui.js
│     ├─ prettify.js
│     ├─ prettify/
│     │  └─ run_prettify.js
│     ├─ components/
│     │  └─ extended-format-date.js
│     ├─ common.js
│     ├─ boot.min.js        ⤆ nouveau fichier
│     ├─ framework.min.js   ⤆ nouveau fichier
│     └─ common.min.js      ⤆ nouveau fichier
├─ views/
│  └─ index.htm
└─ webconfig.json
</code></pre><h4 id="bundles-dans-un-fichier-partag-">Bundles dans un fichier partagé</h4><p>Afin de ne pas réécrire une longue liste de configuration de Bundles dans un fichier <code>webconfig.json</code> à destination de votre environnement de développement et <code>webconfig.prod.json</code> à destination de votre environnement de production, vous pouvez mutualiser la déclaration des fichiers dans un fichier de votre choix. Par convention, c'est le fichier <code>bundles.json</code>.</p><p>Par exemple :</p><p>L'ensemble de fichier suivant</p><pre><code>├─ assets/
│  ├─ stylesheets/
│  │  ├─ common.css
│  │  ├─ common-min780.css
│  │  └─ common-min1160.css
│  └─ javascripts/
│     ├─ modernizr.js
│     ├─ yepnot.js
│     ├─ html5Shiv.js
│     ├─ jquery.js
│     ├─ jquery-ui.js
│     ├─ prettify.js
│     ├─ prettify/
│     │  └─ run_prettify.js
│     ├─ components/
│     │  └─ extended-format-date.js
│     └─ common.js
├─ views/
│  └─ index.htm
├─ webconfig.json
└─ webconfig.prod.json
</code></pre><p>avec <code>webconfig.json</code></p><pre><code class="lang-json">{
    "httpPort": 7777,
    "bundles": {
        "javascripts": {
            "javascripts/boot.min.js": [
                "javascripts/modernizr.js",
                "javascripts/yepnot.js",
                "javascripts/html5Shiv.js"
            ],
            "javascripts/framework.min.js": [
                "javascripts/jquery.js",
                "javascripts/jquery-ui.js",
                "javascripts/prettify.js",
                "javascripts/prettify/run_prettify.js"
            ],
            "javascripts/common.min.js": [
                "javascripts/components/extended-format-date.js",
                "javascripts/common.js"
            ]
        },
        "stylesheets": {
            "stylesheets/common.min.css": [
                "stylesheets/common.css",
                "stylesheets/common-min780.css",
                "stylesheets/common-min1160.css"
            ]
        }
    },
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>et avec <code>webconfig.prod.json</code></p><pre><code class="lang-json">{
    "httpPort": 7776,
    "httpHostname": "blog.lesieur.name",
    "urlPort": 80,
    "bundles": {
        "javascripts": {
            "javascripts/boot.min.js": [
                "javascripts/modernizr.js",
                "javascripts/yepnot.js",
                "javascripts/html5Shiv.js"
            ],
            "javascripts/framework.min.js": [
                "javascripts/jquery.js",
                "javascripts/jquery-ui.js",
                "javascripts/prettify.js",
                "javascripts/prettify/run_prettify.js"
            ],
            "javascripts/common.min.js": [
                "javascripts/components/extended-format-date.js",
                "javascripts/common.js"
            ]
        },
        "stylesheets": {
            "stylesheets/common.min.css": [
                "stylesheets/common.css",
                "stylesheets/common-min780.css",
                "stylesheets/common-min1160.css"
            ]
        }
    },
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>pourrait devenir l'ensemble de fichier suivant</p><pre><code>├─ assets/
│  ├─ stylesheets/
│  │  ├─ common.css
│  │  ├─ common-min780.css
│  │  └─ common-min1160.css
│  └─ javascripts/
│     ├─ modernizr.js
│     ├─ yepnot.js
│     ├─ html5Shiv.js
│     ├─ jquery.js
│     ├─ jquery-ui.js
│     ├─ prettify.js
│     ├─ prettify/
│     │  └─ run_prettify.js
│     ├─ components/
│     │  └─ extended-format-date.js
│     └─ common.js
├─ views/
│  └─ index.htm
├─ bundles.json              ⤆ nouveau fichier
├─ webconfig.json
└─ webconfig.prod.json
</code></pre><p>avec <code>webconfig.json</code></p><pre><code class="lang-json">{
    "httpPort": 7777,
    "bundles": "bundles.json",
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>avec <code>webconfig.prod.json</code></p><pre><code class="lang-json">{
    "httpPort": 7776,
    "httpHostname": "blog.lesieur.name",
    "urlPort": 80,
    "bundles": "bundles.json",
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>et <code>bundles.json</code></p><pre><code class="lang-json">{
    "javascripts": {
        "javascripts/boot.min.js": [
            "javascripts/modernizr.js",
            "javascripts/yepnot.js",
            "javascripts/html5Shiv.js"
        ],
        "javascripts/framework.min.js": [
            "javascripts/jquery.js",
            "javascripts/jquery-ui.js",
            "javascripts/prettify.js",
            "javascripts/prettify/run_prettify.js"
        ],
        "javascripts/common.min.js": [
            "javascripts/components/extended-format-date.js",
            "javascripts/common.js"
        ]
    },
    "stylesheets": {
        "stylesheets/common.min.css": [
            "stylesheets/common.css",
            "stylesheets/common-min780.css",
            "stylesheets/common-min1160.css"
        ]
    }
}
</code></pre><p><em>Note : il est possible de désactiver les Bundles en ne les incluant pas dans le <code>webconfig</code> en question.</em></p><h4 id="d-sactiver-des-bundles">Désactiver des Bundles</h4><p>Il est également possible de ne pas exécuter la minification au démarrage d'un site web avec NodeAtlas avec les propriétés <code>"cssBundlingEnable": false</code> et <code>"jsBundlingEnable": false</code> pour chaque type de Bundle.</p><pre><code class="lang-json">{
    "cssBundlingEnable": false,
    "jsBundlingEnable": false,
    "bundles": {
        "javascripts": {
            "javascripts/boot.min.js": [
                "javascripts/modernizr.js",
                "javascripts/yepnot.js",
                "javascripts/html5Shiv.js"
            ],
            "javascripts/framework.min.js": [
                "javascripts/jquery.js",
                "javascripts/jquery-ui.js",
                "javascripts/prettify.js",
                "javascripts/prettify/run_prettify.js"
            ],
            "javascripts/common.min.js": [
                "javascripts/components/extended-format-date.js",
                "javascripts/common.js"
            ]
        },
        "stylesheets": {
            "stylesheets/common.min.css": [
                "stylesheets/common.css",
                "stylesheets/common-min780.css",
                "stylesheets/common-min1160.css"
            ]
        }
    },
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p><em>Note : si vos bundles sont dans un fichier partagé, vous pouvez également les désactiver simplement en retirand la ligne <code>"bundles": "bundles.json"</code>.</em></p><h4 id="r-g-n-rer-les-bundles-avant-chaque-rendu-de-page">Ré-générer les Bundles avant chaque rendu de page</h4><p>De manière à toujours tester vos page avec les fichiers minifiés, vous pouvez demander à ce qu'ils soient régénérés avant chaque affichage de page avec les propriétés <code>"cssBundlingBeforeResponse": true</code> et <code>"jsBundlingBeforeResponse": true</code> pour chaque type de Bundle.</p><pre><code class="lang-json">{
    "cssBundlingBeforeResponse": false,
    "jsBundlingBeforeResponse": false,
    "bundles": {
        "javascripts": {
            "javascripts/boot.min.js": [
                "javascripts/modernizr.js",
                "javascripts/yepnot.js",
                "javascripts/html5Shiv.js"
            ],
            "javascripts/framework.min.js": [
                "javascripts/jquery.js",
                "javascripts/jquery-ui.js",
                "javascripts/prettify.js",
                "javascripts/prettify/run_prettify.js"
            ],
            "javascripts/common.min.js": [
                "javascripts/components/extended-format-date.js",
                "javascripts/common.js"
            ]
        },
        "stylesheets": {
            "stylesheets/common.min.css": [
                "stylesheets/common.css",
                "stylesheets/common-min780.css",
                "stylesheets/common-min1160.css"
            ]
        }
    },
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p><em>Note : ceci n'est pas conseillé en production car cela ralenti les réponses des pages.</em></p><h4 id="version-dans-noms-de-fichiers-g-n-r-s">Version dans noms de fichiers générés</h4><p>Afin de forcer le navigateur à charger de nouveau vos fichiers en cache il est intéressant de changer leur nom pour chaque version. Ainsi avec l'occurence <code>{version}</code> sera remplacé par le numéro de version de votre site actuel (par défaut <code>0.0.0</code>).</p><p>Ainsi, si vous avez un fichier <code>package.json</code> ou un <code>webconfig.json</code> valide avec un numéro de version indiqué sous la propriété version, ce numéro remplacera la valeur <code>{version}</code>. Ainsi avec le webconfig suivant :</p><p><em>webconfig</em></p><pre><code class="lang-js">{
    "version": "1.0.0",
    "bundles": "bundles.json"
    "routes": "routes.json"
}
</code></pre><p>et les bundles suivants :</p><p><em>bundles.json</em></p><pre><code class="lang-json">{
    "javascripts": {
        "javascripts/boot.{version}.min.js": [
            "javascripts/modernizr.js",
            "javascripts/yepnot.js",
            "javascripts/html5Shiv.js"
        ]
    },
    "stylesheets": {
        "stylesheets/common.{version}.min.css": [
            "stylesheets/common.css",
            "stylesheets/common-min780.css",
            "stylesheets/common-min1160.css"
        ]
    }
}
</code></pre><p>vous obtiendrez les fichiers <code>assets/javascripts/boot.1.0.0.min.js</code> et <code>assets/javascripts/common.1.0.0.min.css</code>.</p><p>que vous pourrez appeler ainsi :</p><p><em>views/*.htm</em></p><pre><code class="lang-htm"><!-- ... -->

<link rel="stylesheet" href="stylesheets/common.<?= webconfig.version ?>.min.css">

<!-- ... -->

<script src="javascripts/boot.<?= webconfig.version ?>.min.js"></script>

<!-- ... -->
</code></pre><h4 id="bundles-avec-sockets">Bundles avec Sockets</h4><p>Il est possible de minifier le fichier défini par <code>NA.webconfig.socketClientFile</code> même si celui-ci n'existe pas physiquement. Il suffit pour cela de le glisser dans les bundles souhaité.</p><p>Dans l'exemple suivant, le fichier virtuel <code>node-atlas/socket.io.js</code> sera ajouté aux sources avec la bonne configuration pour faire le lien client/serveur.</p><pre><code class="lang-json">{
    "bundles": {
        "javascripts": {
            "javascripts/common.min.js": [
                "javascripts/socket.io.js",
                "node-atlas/socket.io.js",
                "javascripts/common.js"
            ]
        }
    },
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><h3 id="generer-les-css-avec-less">Générer les CSS avec Less</h3><p>Vous pouvez utiliser le préprocesseur Less pour créer vos CSS. Le fonctionnement est le suivant : à chaque fois qu'une requête CSS est effectuée, si un équivalent Less existe il est lu et celui-ci génère le CSS. Une fois l'opération effectuée, on renvoi le CSS demandée.</p><p>Avec la structure suivante :</p><pre><code>├─ assets/
│  └─ stylesheets
│     └─ common.less
├─ views/
│  └─ index.htm
└─ webconfig.json
</code></pre><p>ainsi que le webconfig suivante :</p><pre><code class="lang-json">{
    "less": true,
    "routes": {
        "/": "index.htm"
    }
}
</code></pre><p>et le contenu suivant dans :</p><p><em>views/index.htm</em></p><pre><code class="lang-html"><!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Less Test</title>
        <link rel="stylesheet" href="stylesheets/common.css">
    </head>
    <body>
        <p>This line is red.</p>
    </body>
</html>
</code></pre><p><em>assets/stylesheets/common.less</em></p><pre><code class="lang-css">p {
    color: #f00;
}
</code></pre><p>vous générerez le fichier <code>assets/stylesheets/common.css</code> en appelant l'url <code>http://localhost/</code> ou <code>http://localhost/stylesheets/common.css</code>.</p><h4 id="source-map-minification-et-autoprefix">Source Map, Minification et Autoprefix</h4><p>Par défaut, dans l'exemple ci-dessus un fichier <code>common.css.map</code> sera généré. Celui-ci permet à votre navigateur de vous indiquer qu'elle ligne du fichier <code>.less</code> a générée la propriété CSS de l'élément que vous avez sélectionné dans votre débuggeur.</p><p>Cela se désactive avec <code>less.sourceMap</code> à <code>false</code> :</p><pre><code class="lang-json">    "less": {
        "sourceMap": false
    },
    "routes": {
        "/": "index.htm"
    }
</code></pre><p>Vous pouvez également générer des fichiers CSS déjà minifiés avec :</p><pre><code class="lang-json">    "less": {
        "compress": true
    },
    "routes": {
        "/": "index.htm"
    }
</code></pre><p>Pour finir, vous pouvez également ajouter automatiquement les prefix vendeur comme <code>--webkit</code>, <code>--moz</code>, <code>--ms</code>, <code>--o</code> lors de la génération sans vous en préoccuper dans vos sources !</p><pre><code class="lang-json">    "less": {
        "autoprefix": true
    },
    "routes": {
        "/": "index.htm"
    }
</code></pre><h4 id="compiler-les-less-avec-generate-">Compiler les Less avec <code>--generate</code></h4><p>Comme les Less sont compilés a la volé, quand le fichier est demandé en http(s), toutes modifications dans le Less demandera de faire tourner le site pour la répercuter dans le CSS. Ensuite seulement vous pourrez minifier vos CSS. Il est possible d'automatiser cette tâche pour ne pas avoir à démarrer le site grâce à <code>less.files</code>.</p><p>Avec le <code>webconfig.json</code> suivant :</p><pre><code class="lang-json">{
    "less": {
        "files": [
            "stylesheets/common.less",
            "stylesheets/component-1.less",
            "stylesheets/component-2.less",
            "stylesheets/component-3.less"
        ]
    },
    "routes": {
        "/": "index.htm"
    }
}
</code></pre><p>ou suivante :</p><pre><code class="lang-json">{
    "less": {
        "files": "less.json"
    },
    "routes": {
        "/": "index.htm"
    }
}
</code></pre><p>avec <code>less.json</code> qui contient :</p><pre><code class="lang-json">[
    "stylesheets/common.less",
    "stylesheets/component-1.less",
    "stylesheets/component-2.less",
    "stylesheets/component-3.less"
]
</code></pre><p>Par défaut, les <code>@import</code> utilisés par Less seront capable de fouiller dans les sous dossier : <code>styles</code>, <code>stylesheets</code> ou <code>css</code>. Il est possible de changer cela avec :</p><pre><code class="lang-json">{
    "less": {
        "paths": [
            "subdirectory/styles-files",
        ],
        "files": "less.json"
    },
    "routes": {
        "/": "index.htm"
    }
}
</code></pre><h3 id="generer-les-css-avec-stylus">Générer les CSS avec Stylus</h3><p>Vous pouvez utiliser le préprocesseur Stylus pour créer vos CSS. Le fonctionnement est le suivant : à chaque fois qu'une requête CSS est effectuée, si un équivalent Stylus existe il est lu et celui-ci génère le CSS. Une fois l'opération effectuée, on renvoi le CSS demandée.</p><p>Avec la structure suivante :</p><pre><code>├─ assets/
│  └─ stylesheets
│     └─ common.styl
├─ views/
│  └─ index.htm
└─ webconfig.json
</code></pre><p>ainsi que le webconfig suivante :</p><pre><code class="lang-json">{
    "stylus": true,
    "routes": {
        "/": "index.htm"
    }
}
</code></pre><p>et le contenu suivant dans :</p><p><em>views/index.htm</em></p><pre><code class="lang-html"><!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Stylus Test</title>
        <link rel="stylesheet" href="stylesheets/common.css">
    </head>
    <body>
        <p>This line is red.</p>
    </body>
</html>
</code></pre><p><em>assets/stylesheets/common.styl</em></p><pre><code class="lang-css">p
    color: #f00
</code></pre><p>vous générerez le fichier <code>assets/stylesheets/common.css</code> en appelant l'url <code>http://localhost/</code> ou <code>http://localhost/stylesheets/common.css</code>.</p><h4 id="source-map-minification-et-autoprefix">Source Map, Minification et Autoprefix</h4><p>Par défaut, dans l'exemple ci-dessus un fichier <code>common.css.map</code> sera généré. Celui-ci permet à votre navigateur de vous indiquer qu'elle ligne du fichier <code>.styl</code> a générée la propriété CSS de l'élément que vous avez sélectionné dans votre débuggeur.</p><p>Cela se désactive avec <code>stylus.sourceMap</code> à <code>false</code> :</p><pre><code class="lang-json">    "stylus": {
        "sourceMap": false
    },
    "routes": {
        "/": "index.htm"
    }
</code></pre><p>Vous pouvez également générer des fichiers CSS déjà minifiés avec :</p><pre><code class="lang-json">    "stylus": {
        "compress": true
    },
    "routes": {
        "/": "index.htm"
    }
</code></pre><p>Pour finir, vous pouvez également ajouter automatiquement les prefix vendeur comme <code>--webkit</code>, <code>--moz</code>, <code>--ms</code>, <code>--o</code> lors de la génération sans vous en préoccuper dans vos sources !</p><pre><code class="lang-json">    "stylus": {
        "autoprefix": true
    },
    "routes": {
        "/": "index.htm"
    }
</code></pre><p><em>Note:</em> Plus d'options sur <a href="https://www.npmjs.com/package/stylus">la documentation du module stylus</a>.</p><h4 id="compiler-les-stylus-avec-generate-">Compiler les Stylus avec <code>--generate</code></h4><p>Comme les Stylus sont compilés a la volé, quand le fichier est demandé en http(s), toutes modifications dans le Stylus demandera de faire tourner le site pour la répercuter dans le CSS. Ensuite seulement vous pourrez minifier vos CSS. Il est possible d'automatiser cette tâche pour ne pas avoir à démarrer le site grâce à <code>stylus.files</code>.</p><p>Avec le <code>webconfig.json</code> suivant :</p><pre><code class="lang-json">{
    "stylus": {
        "files": [
            "stylesheets/common.styl",
            "stylesheets/component-1.styl",
            "stylesheets/component-2.styl",
            "stylesheets/component-3.styl"
        ]
    },
    "routes": {
        "/": "index.htm"
    }
}
</code></pre><p>ou suivante :</p><pre><code class="lang-json">{
    "stylus": {
        "files": "stylus.json"
    },
    "routes": {
        "/": "index.htm"
    }
}
</code></pre><p>avec <code>stylus.json</code> qui contient :</p><pre><code class="lang-json">[
    "stylesheets/common.styl",
    "stylesheets/component-1.styl",
    "stylesheets/component-2.styl",
    "stylesheets/component-3.styl"
]
</code></pre><p>Par défaut, les <code>@import</code> utilisés par Stylus seront capable de fouiller dans les sous dossier : <code>styles</code>, <code>stylesheets</code> ou <code>css</code>. Il est possible de changer cela avec :</p><pre><code class="lang-json">{
    "stylus": {
        "paths": [
            "subdirectory/styles-files",
        ],
        "files": "stylus.json"
    },
    "routes": {
        "/": "index.htm"
    }
}
</code></pre><h3 id="optimiser-les-images">Optimiser les Images</h3><p>Vous pouvez automatiquement optimiser les images que vous allez utiliser dans votre site pour en limiter le poids de chargement en créant des Optimizations en référençant les fichiers d'entrés par leur chemin d'accès et le chemin du dossier de sortie. Vous pouvez bien entendu en faire autant que vous le souhaitez. L'optimisation des images se fait à chaque démarrage de NodeAtlas que ce soit en tant que serveur ou via la commande <code>--generate</code> pour peu que des Optimizations existe dans le Webconfig.</p><h4 id="cr-er-des-optimizations">Créer des Optimizations</h4><p>Avec la configuration suivante :</p><pre><code class="lang-json">{
    "optimizations": {
        "images": {
            "media/images/example.png": "media/images/optimized/",
            "media/images/example.jpg": "media/images/optimized/",
            "media/images/example.gif": "media/images/optimized/",
            "media/images/example.svg": "media/images/optimized/"
        }
    },
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>et l'ensemble de fichier suivant :</p><pre><code>├─ assets/
│  └─ media/
│     └─ images/
│        ├─ example.png
│        ├─ example.jpg
│        ├─ example.gif
│        └─ example.svg
├─ views/
│  └─ index.htm
└─ webconfig.json
</code></pre><p>vous obtiendrez les nouveaux fichiers suivant :</p><pre><code>├─ assets/
│  └─ media/
│     └─ images/
│        ├─ example.png
│        ├─ example.jpg
│        ├─ example.gif
│        ├─ example.svg
│        └─ optimized/       ⤆ nouveau dossier
│           ├─ example.png   ⤆ nouveau fichier
│           ├─ example.jpg   ⤆ nouveau fichier
│           ├─ example.gif   ⤆ nouveau fichier
│           └─ example.svg   ⤆ nouveau fichier
├─ views/
│  └─ index.htm
└─ webconfig.json
</code></pre><h4 id="cr-er-des-optimizations-par-groupes-de-fichier">Créer des Optimizations par groupes de fichier</h4><p>Vous pouvez par exemple, plutôt que d'indiquer les fichiers un par un, les indiquer en groupe :</p><pre><code class="lang-json">{
    "optimizations": {
        "images": {
            "media/images/*.{gif,jpg,png,svg}": "media/images/optimized/"
        }
    },
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><h4 id="ajouter-des-options-aux-optimizations">Ajouter des options aux Optimizations</h4><p>Il est possible de redéfinir les options par défaut pour l'optimisation via ses 4 objets :</p><pre><code class="lang-json">{
    "optimizations": {
        "jpg": { "progressive": false },
        "gif": { "interlaced": false },
        "png": { "optimizationLevel": 1 },
        "svg": { "multipass": false },
        "images": {
            "media/images/*.{gif,jpg,png,svg}": "media/images/optimized/"
        }
    },
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>Pour connaître toutes les options c'est par ici :</p><ul>
<li><a href="https://www.npmjs.com/package/imagemin-jpegtran">Options Jpeg</a></li>
<li><a href="https://www.npmjs.com/package/imagemin-gifsicle">Options Gif</a></li>
<li><a href="https://www.npmjs.com/package/imagemin-optipng">Options Png</a></li>
<li><a href="https://www.npmjs.com/package/imagemin-svgo">Options Svg</a></li>
</ul><h4 id="optimizations-dans-un-fichier-partag-">Optimizations dans un fichier partagé</h4><p>Afin de ne pas réécrire une longue liste de configuration d'Optimizations dans un fichier <code>webconfig.json</code> à destination de votre environnement de développement et <code>webconfig.prod.json</code> à destination de votre environnement de production, vous pouvez mutualiser la déclaration des fichiers dans un fichier de votre choix. Par convention, c'est le fichier <code>optimizations.json</code>.</p><p>Par exemple :</p><p>L'ensemble de fichier suivant</p><pre><code>├─ assets/
│  └─ media/
│     └─ images/
│        ├─ example.png
│        ├─ example.jpg
│        ├─ example.gif
│        └─ example.svg
├─ views/
│  └─ index.htm
├─ webconfig.json
└─ webconfig.prod.json
</code></pre><p>avec <code>webconfig.json</code></p><pre><code class="lang-json">{
    "httpPort": 7777,
    "optimizations": {
        "images": {
            "media/images/example.png": "media/images/optimized/",
            "media/images/example.jpg": "media/images/optimized/",
            "media/images/example.gif": "media/images/optimized/",
            "media/images/example.svg": "media/images/optimized/"
        }
    },
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>et avec <code>webconfig.prod.json</code></p><pre><code class="lang-json">{
    "httpPort": 7776,
    "httpHostname": "blog.lesieur.name",
    "urlPort": 80,
    "optimizations": {
        "images": {
            "media/images/example.png": "media/images/optimized/",
            "media/images/example.jpg": "media/images/optimized/",
            "media/images/example.gif": "media/images/optimized/",
            "media/images/example.svg": "media/images/optimized/"
        }
    },
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>pourrait devenir l'ensemble de fichier suivant</p><pre><code>├─ assets/
│  └─ media/
│     └─ images/
│        ├─ example.png
│        ├─ example.jpg
│        ├─ example.gif
│        └─ example.svg
├─ views/
│  └─ index.htm
├─ bundles.json
├─ webconfig.json
└─ webconfig.prod.json
</code></pre><p>avec <code>webconfig.json</code></p><pre><code class="lang-json">{
    "httpPort": 7777,
    "optimizations": "optimizations.json",
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>avec <code>webconfig.prod.json</code></p><pre><code class="lang-json">{
    "httpPort": 7776,
    "httpHostname": "blog.lesieur.name",
    "urlPort": 80,
    "optimizations": "optimizations.json",
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p>et <code>optimizations.json</code></p><pre><code class="lang-json">{
    "images": {
        "media/images/example.png": "media/images/optimized/",
        "media/images/example.jpg": "media/images/optimized/",
        "media/images/example.gif": "media/images/optimized/",
        "media/images/example.svg": "media/images/optimized/"
    }
}
</code></pre><p><em>Note : il est possible de désactiver les Optimizations en ne les incluant pas dans le <code>webconfig</code> en question.</em></p><h4 id="d-sactiver-des-optimizations">Désactiver des Optimizations</h4><p>Il est également possible de ne pas exécuter l'optimisation au démarrage d'un site web avec NodeAtlas avec les propriétés <code>"imgOptimizationsEnable": false</code>.</p><pre><code class="lang-json">{
    "imgOptimizationsEnable": false,
    "optimizations": {
        "images": {
            "media/images/example.png": "media/images/optimized/",
            "media/images/example.jpg": "media/images/optimized/",
            "media/images/example.gif": "media/images/optimized/",
            "media/images/example.svg": "media/images/optimized/"
        }
    },
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p><em>Note : si vos optimizations sont dans un fichier partagé, vous pouvez également les désactiver simplement en retirant la ligne <code>"optimizations": "optimizations.json"</code>.</em></p><h4 id="r-g-n-rer-les-optimizations-avant-chaque-rendu-de-page">Ré-générer les Optimizations avant chaque rendu de page</h4><p>Vous pouvez demander à ce que les fichiers soient régénérés avant chaque affichage de page avec les propriétés <code>"imgOptimizationsBeforeResponse": true</code>.</p><pre><code class="lang-json">{
    "imgOptimizationsBeforeResponse": false,
    "optimizations": {
        "images": {
            "media/images/example.png": "media/images/optimized/",
            "media/images/example.jpg": "media/images/optimized/",
            "media/images/example.gif": "media/images/optimized/",
            "media/images/example.svg": "media/images/optimized/"
        }
    },
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p><em>Note : ceci n'est pas conseillé en production car cela ralenti les réponses des pages.</em></p><h3 id="injecter-du-css-inline-pour-maintenir-des-assets-email">Injecter du CSS inline pour maintenir des assets Email</h3><p>Quand on créer des templates pour envoyer des Newsletters par email, ou même de simple message, on ne peut pas attacher de feuille de style. Le seul moyen à notre disposition est d'écrire les instructions CSS dans le template à l'intérieur de l'attribut <code>style</code> brisant ainsi la séparation du font et de la forme.</p><h4 id="injection-sp-cifique">Injection spécifique</h4><p>Avec <code>injectCss</code>, il vous suffit d'habiller votre template comme à votre habitude via une feuille de style et NodeAtlas injectera à chaque rendu les styles dans l'attribut <code>style</code>. Il ne vous restera plus qu'à générer vos templates.</p><p>Avec par exemple la configuration suivante :</p><pre><code class="lang-json">{
    "routes": {
        "/": {
            "view": "email.htm",
            "output": "bienvenue.html",
            "injectCss": "stylesheets/email.css"
        }
    }
}
</code></pre><p>et l'ensemble de fichiers suivant :</p><pre><code>├─ serverless/
├─ assets/
│  └─ stylesheets/
│     └─ email.css
├─ views/
│  └─ email.htm
└─ webconfig.json
</code></pre><p>dont les contenus sont :</p><p><em>stylesheets/common.css</em></p><pre><code class="lang-css">body {
    color: #f00;
}
</code></pre><p><em>views/email.htm*</em></p><pre><code class="lang-html"><!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Email</title>
    </head>
    <body>
        <p>This is a template email.</p>
    </body>
</html>
</code></pre><p>vous obtiendrez en sortie avec la commande <code>node-atlas --generate</code> l'ensemble de fichier suivant :</p><pre><code>├─ serverless/
│  └─ bienvenue.html    <= template email prêt à l'envoi !
├─ assets/
│  └─ stylesheets/
│     └─ email.css
├─ views/
│  └─ email.htm
└─ webconfig.json
</code></pre><p>avec comme contenu pour <code>serverless/bienvenue.html</code></p><pre><code class="lang-html"><!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Email</title>
    </head>
    <body style="color: #f00;">
        <p>This is a template email.</p>
    </body>
</html>
</code></pre><p>Ce mécanisme marche également si vous n'avez pas l'intention de générer quoi que ce soit mais sur un site qui tourne. Pratique pour modifier vos maquettes en live avant de les générer.</p><blockquote>
<p>Test : Depuis <code>./tests/examples/css-injection</code> lancez <code>node "../../../" --generate</code>. Le résultat est dans <code>serverless</code>.</p>
</blockquote><h4 id="injection-globale">Injection globale</h4><p>Il existe également la même propriété globale impactant toutes les pages.</p><pre><code class="lang-json">{
    "injectCss": "stylesheets/email.css",
    "routes": {
        "/bienvenue/": {
            "view": "email-a.htm",
            "generate": "bienvenue.html"
        },
        "/au-revoir/": {
            "view": "email-b.htm",
            "generate": "au-revoir.html"
        }
    }
}
</code></pre><p>ainsi les deux pages <code>bienvenue</code> et <code>au-revoir</code> contiendront chacune <code><body style="color: #f00;"></code>.</p><h4 id="injection-multiple">Injection multiple</h4><p>Il est possible :</p><ul>
<li>De préciser des feuilles spécifique et commune en même temps.</li>
<li>De préciser plus d'une feuille à la fois.</li>
</ul><pre><code class="lang-json">{
    "injectCss": ["stylesheets/reset.css", "stylesheets/email.css"],
    "routes": {
        "/bienvenue/": {
            "view": "email-a.htm",
            "generate": "bienvenue.html",
            "injectCss": "/stylesheets/welcome.css"
        },
        "/au-revoir/": {
            "view": "email-b.htm",
            "generate": "au-revoir.html",
            "injectCss": ["stylesheets/good-bye.css", "/stylesheets/others.css"]
        }
    }
}
</code></pre><blockquote>
<p>Test : Depuis <code>./tests/examples/css-injection</code> lancez <code>node "../../../" --generate --webconfig webconfig.multiple.json</code>. Le résultat est dans <code>serverless</code>.</p>
</blockquote><h3 id="autoriser-interdire-les-demandes-get-post">Autoriser / Interdire les demandes GET / POST</h3><p>Vous pouvez également manager la manière dont le serveur va répondre aux demandes GET/POST pour une page donnée. Par exemple, nous allons autoriser l'accès aux pages uniquement en GET pour tout le site et autoriser un POST pour une page seulement (et même lui interdire le GET).</p><pre><code class="lang-json">{
    "get": true,
    "post": false,
    "routes": {
        "/": {
            "view": "index.htm"
        },
        "/liste-des-membres/": {
            "view": "members.htm"
        },
        "/rediger-commentaire/": {
            "view": "write-com.htm"
        },
        "/commentaire-sauvegarde/": {
            "view": "save-com.htm",
            "get": false,
            "post": true
        }
    }
}
</code></pre><p><em>Note : Si rien n'est précisé,</em> <code>get</code> <em>et</em> <code>post</code> <em>sont à</em> <code>true</code> <em>au niveau global et par page.</em></p><h3 id="autoriser-interdire-les-demandes-put-delete">Autoriser / Interdire les demandes PUT / DELETE</h3><p>Fonctionnant exactement de la même manière que <code>get</code> et <code>post</code>, les deux actions HTTP PUT et DELETE qui part défaut ne sont pas activé peuvent être activé avec <code>put</code> et <code>delete</code>.</p><pre><code class="lang-json">{
    "get": false,
    "post": false,
    "put": true,
    "routes": {
        "/read-all-entry/": {
            "view": "display-json.htm",
            "variation": "all-entry.json",
            "get": true,
            "put": false
        },
        "/read-entry/:id/": {
            "view": "display-json.htm",
            "variation": "entry.json",
            "get": true,
            "put": false
        },
        "/create-entry/:id/": {
            "view": "display-json.htm",
            "variation": "entry.json",
            "post": true,
            "put": false
        },
        "/update-entry/:id/": {
            "view": "display-json.htm",
            "variation": "entry.json"
        },
        "/delete-entry/:id/": {
            "view": "display-json.htm",
            "variation": "entry.json",
            "delete": true,
            "put": false
        }
    }
}
</code></pre><p>Avec la configuration ci-dessus, seulement une action HTTP n'est possible par entrée, cela permet de faire des APIs REST facilement avec NodeAtlas.</p><h3 id="gerer-cors-et-les-demandes-options">Gérér CORS et les demandes OPTIONS</h3><p>Par défaut, les requêtes pré-vérifiées ("preflighted requests") ne sont pas activées. Vous allez en avoir besoin pour, par exemple, effectuer des requêtes Cross-Domain ou CORS. Les requêtes pré-vérifiées se font avec la méthode HTTP OPTIONS.</p><p>Pour activer OPTIONS sur une route, utilisez la propriété <code>options</code> sur une route dans le webconfig. Pour activer OPTIONS sur toutes les routes, utilisez alors la propriété options du webconfig sur la configuration global.</p><pre><code class="lang-json">{
    "options": true,
    "routes": {
        "/read-all-entry/": {
            "view": "display-json.htm",
            "variation": "all-entry.json",
            "options": false
        },
        "/create-entry/:id/": {
            "view": "display-json.htm",
            "variation": "entry.json",
            "post": true
        },
        "/delete-entry/:id/": {
            "view": "display-json.htm",
            "variation": "entry.json",
            "delete": true
        }
    }
}
</code></pre><p><strong>Demande Cross-Domain</strong></p><p>Si vous souhaitez authoriser une ressource du serveur NodeAtlas au requête en provenance de <code>www.domain-a.com</code> pour une page précise, vous pouvez le faire ainsi :</p><pre><code class="lang-json">{
    "routes": {
        "/api/random-quote": {
            "controller": "get-quote.js",
            "headers": {
                "Access-Control-Allow-Origin": "http://www.domain-a.com"
            }
        }
    }
}
</code></pre><p>Ainsi vous pourrez par exemple accepter la requête suivante qui a pour <code>Origin</code>, <code>http://www.domain-a.com</code> qui est donc une valeur de <code>Access-Control-Allow-Origin</code> :</p><pre><code class="lang-bash">GET /api/random-quote HTTP/1.1
Host: www.domain-a.com
...
Origin: http://www.domain-a.com
...
</code></pre><p><strong>Demande Cross-Domain avec jeton</strong></p><p>Si vous souhaitez authoriser des ressources du serveur NodeAtlas aux requêtes en provenance de n'importe quel domaine externe pour la page <code>/api/random-quote</code> et une page qui attend un jeton d'authentification pour la page <code>/api/protected/random-quote</code>, vous pouvez le faire ainsi :</p><pre><code class="lang-json">{
    "mimeType": "application/json",
    "headers": {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Headers": "Authorization"
    },
    "routes": {
        "/api/random-quote": {
            "controller": "get-quote.js"
        },
        "/api/protected/random-quote": {
            "controller": "get-quote.js",
            "middlewares": "is-authenticated.js",
            "options": true
        }
    }
}
</code></pre><p>Faire lire un jeton à NodeAtlas depuis un domaine externe nécessite de lui passer l'en-tête HTML <code>Authorization</code>. Pour que celle-ci soit accepté par NodeAtlas il faut le définir avec <code>Access-Control-Allow-Headers</code> acceptant <code>Authorization</code>. L'envoi d'un jeton nécessitant une requête pré-vérifiée, il faut également mettre <code>options</code> à <code>true</code> pour autoriser les requêtes HTTP avec la méthode OPTIONS.</p><p>Ainsi vous pourrez par exemple accepter la requête suivante qui passe un jeton d'authentification à notre serveur pour la ressource <code>/api/protected/random-quote</code> :</p><pre><code class="lang-bash">GET /api/protected/random-quote HTTP/1.1
Host: localhost:1337
...
Origin: http://localhost
Authorization: Bearer CODE_DU_JETON
...
</code></pre><p><strong>Autre demande Cross-Domain</strong></p><p>Toutes les entêtes prévues pour faire fonctionner CORS sont accepté via le mécanisme d'ajout d'en-tête de NodeAtlas.</p><h3 id="changer-les-parametres-des-sessions">Changer les paramètres des Sessions</h3><h4 id="cl-et-secret">Clé et Secret</h4><p>NodeAtlas gère lui-même les sessions stockées sur le serveur avec comme paramètres initiaux :</p><ul>
<li>Key : <code>nodeatlas.sid</code></li>
<li>Secret : <code>1234567890bépo</code></li>
</ul><p>qui permettent à un client de rester connecté à travers les pages à un même ensemble de variable personnelles côtés serveur.</p><p>Il est possible de modifier ses paramètres par défaut (et même obligatoire pour des sites en productions) avec les paramètres de <code>webconfig.json</code> suivant :</p><pre><code class="lang-json">{
    sessionKey: "clé personnelle",
    sessionSecret: "secret personnel"
}
</code></pre><p>NodeAtlas utilise également un objet de stockage mémoire (MemoryStore) qui stocke les informations dans la RAM du serveur.</p><h4 id="autres-param-tres">Autres paramètres</h4><p>Il est possible de changer l'intégralité des paramètres des sessions (sauf le MemoryStore) en utilisant la configuration de <code>webconfig.json</code> suivante :</p><pre><code class="lang-json">{
    "session": {
        "key": "clé personnelle",
        "secret": "secret personnel",
        "cookie": {
            "path": '/',
            "httpOnly": true,
            "secure": false,
            "maxAge": null
        },
        ...,
        ...,
        ...
    }
}
</code></pre><p>L'intégralité de la configuration possible se trouve sur la documentation du module <a href="https://github.com/expressjs/session">express-session</a>.</p><h3 id="stockage-externe-des-sessions">Stockage externe des Sessions</h3><p>Par défaut, c'est NodeAtlas qui stocke les sessions serveurs dans la RAM du serveur par application. Cela ne permet pas de partager des sessions utilisateurs à travers plusieurs applications NodeAtlas (ou autre) et efface toutes les sessions en cours pour une application en cas de redémarrage de celle-ci.</p><p>Pour résoudre ce souci, il convient de prendre en charge l'enregistrement des sessions via une base No SQL tel que <code>Redis</code> ou <code>MongoBD</code>.</p><p>Pour cela il suffit d'utiliser la fonction <code>setSessions</code> dans le fichier de <code>controller</code> commun.</p><h4 id="session-g-r-es-avec-redis">Session gérées avec Redis</h4><p>Implémenter le code suivant dans le <code>controller</code> commun pour stocker vos sessions dans Redis en local.</p><pre><code>exports.setModules = function () {
    var NA = this;

    NA.modules.RedisStore = require("connect-redis");
};

exports.setSessions = function (njsext) {
    var NA = this,
        session = NA.modules.session,
        RedisStore = NA.modules.RedisStore(session);

    NA.sessionStore = new RedisStore();

    next();
};
</code></pre><p>Plus d'informations sur <a href="https://www.npmjs.org/package/connect-redis">connect-redis</a>.</p><h4 id="session-g-r-es-avec-mongodb">Session gérées avec MongoDB</h4><p>Implémenter le code suivant dans <code>controllers/common.js</code> pour stocker vos sessions dans la database <code>sessions</code> d'une MongoDB locale.</p><pre><code>exports.setModules = function () {
    var NA = this;

    NA.modules.MongoStore = require("connect-mongo");
};

exports.setSessions = function (next) {
    var NA = this,
        session = NA.modules.session,
        MongoStore = NA.modules.MongoStore(session);

    NA.sessionStore = new MongoStore({
        db: "sessions"
    });

    next();
};
</code></pre><p>Plus d'informations sur <a href="https://www.npmjs.org/package/connect-mongo">connect-redis</a>.</p><h3 id="changer-l-url-final-des-hostname-et-port-d-ecoute">Changer l'url final des hostname et port d'écoute</h3><p>Il est possible de générer une url de visite différente des paramètres d'écoutes demandés avec <code>urlHostname</code> et <code>urlPort</code>. Par exemple on écoute la boucle local sur le port 80 car un script fait du Reverse Proxy depuis le port 7777 sur le 80 avec le module « http-proxy » comme ci-dessous :</p><pre><code class="lang-json">{
    "httpPort": 7777,
    "httpHostname": "127.0.0.1",
    "urlPort": 80,
    "urlHostname": "localhost",
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><h3 id="generer-les-urls-dynamiquement">Générer les urls dynamiquement</h3><h4 id="les-chemins-relatifs-en-absolue">Les chemins relatifs en absolue</h4><p>Il est possible que les chemins créés à partir de votre url soient interprétés comme des sous-dossiers qui n'ont en réalité aucune existence réelle. Cela a pour conséquence de rendre l'adresse <code>media/images/example.jpg</code> initialement accessible depuis un template affiché à <strong><a href="http://localhost">http://localhost</a></strong> impossible à récupérer quand le template est affiché à <strong><a href="http://localhost/sub-directory/">http://localhost/sub-directory/</a></strong> (puisqu'il faudrait alors que notre chemin soit plutôt <code>../media/images/example.jpg</code>).</p><p>Pour ne plus avoir à se soucier de l'accès aux ressources peu importe l'url qui est demandée, il suffit de transformer toutes les urls relatives telles que :</p><pre><code><link rel="stylesheet" type="text/css" href="stylesheets/common.css" />
<!-- ... -->
<img src="media/images/example.jpg" />
<!-- ... -->
<script type="text/javascript" src="javascripts/common.js"></script>
</code></pre><p>en urls absolues avec la variable <code>urlBasePath</code> comme ci-dessous :</p><pre><code><link rel="stylesheet" type="text/css" href="<?= urlBasePath ?>stylesheets/common.css" />
<!-- ... -->
<img src="<?= urlBasePath ?>media/images/example.jpg" />
<!-- ... -->
<script type="text/javascript" src="<?= urlBasePath ?>javascripts/common.js"></script>
</code></pre><p>À noter que dans le cas de la configuration suivante :</p><pre><code class="lang-json">{
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p><code>urlBasePath</code> retourne <code>http://localhost/</code> alors que dans celle-ci :</p><pre><code class="lang-json">{
    "httpPort": 7777,
    "urlRelativeSubPath": "sub/folder",
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}
</code></pre><p><code>urlBasePath</code> retourne <code>http://localhost:7777/sub/folder/</code>.</p><h4 id="les-chemins-des-templates">Les chemins des templates</h4><p>En utilisant le webconfig suivant :</p><pre><code class="lang-json">{
    "routes": {
        "/index.html": {
            "view": "index.htm"
        },
        "/contact.html": {
            "view": "contact.htm"
        }
    }
}
</code></pre><p>ainsi que la view <code>index.htm</code> correspondante</p><pre><code class="lang-html"><!-- ... -->
<a href="http://localhost/index.html">Lien vers l'accueil</a>
<a href="http://localhost/contact.html">Lien pour nous contacter</a>
<!-- ... -->
</code></pre><p>je serais obligé de changer mon lien dans le template si je change le port d'écoute ou si je change le chemin de l'url. Le changement de configuration suivant :</p><pre><code class="lang-json">{
    "httpPort": 7777,
    "routes": {
        "/home.html": {
            "view": "index.htm"
        },
        "/contact-us.html": {
            "view": "contact.htm"
        }
    }
}
</code></pre><p>me contraindrait à modifier le template précédent comme suit :</p><pre><code class="lang-html"><!-- ... -->
<a href="http://localhost:7777/home.html">Lien vers l'accueil</a>
<a href="http://localhost:7777/contact-us.html">Lien pour nous contacter</a>
<!-- ... -->
</code></pre><p>Il est possible de solutionner ce problème en donnant une clé à un chemin précis et en déportant son chemin dans la propriété <code>url</code>.</p><p>Avec le webconfig suivant :</p><pre><code class="lang-json">{
    "routes": {
        "index": {
            "url": "/index.html",
            "view": "index.htm"
        },
        "contact": {
            "url": "/contact.html",
            "view": "contact.htm"
        }
    }
}
</code></pre><p>je peux à présent écrire le lien dans le template de manière dynamique :</p><ol>
<li><p>comme suit</p>
<pre><code class="lang-html"><!-- ... -->
<a href="<?= urlBasePath ?><?= webconfig.routes.home.url.slice(1) ?>">Lien vers l'accueil</a>
<a href="<?= urlBasePath ?><?= webconfig.routes.contact.url.slice(1) ?>">Lien pour nous contacter</a>
<!-- ... -->
</code></pre>
<p><em>Note : <code>.slice(1)</code> permet de supprimer facilement le double <code>/</code> pour une url fonctionnelle.</em></p>
</li>
<li><p>ou comme suit</p>
<pre><code class="lang-html"><!-- ... -->
<a href="<?= urlBasePath ?>.<?= webconfig.routes.home.url ?>">Lien vers l'accueil</a>
<a href="<?= urlBasePath ?>.<?= webconfig.routes.contact.url ?>">Lien pour nous contacter</a>
<!-- ... -->
</code></pre>
<p><em>Note : Cela donnerait par exemple <code>http://localhost/./home.html</code>, ce qui est une url fonctionnelle.</em></p>
</li>
<li><p>ou comme suit</p>
<pre><code class="lang-html"><!-- ... -->
<a href="<?= urlBasePathSlice + webconfig.routes.home.url ?>">Lien vers l'accueil</a>
<a href="<?= urlBasePathSlice + webconfig.routes.contact.url ?>">Lien pour nous contacter</a>
<!-- ... -->
</code></pre>
<p><em>Note : <code>urlBasePathSlice</code> renvoyant <code>http://localhost</code> au lieu de <code>http://localhost/</code> ou encore <code>http://localhost:7777/sub/folder</code> au lieu de <code>http://localhost:7777/sub/folder/</code>.</em></p>
</li>
</ol><h4 id="utilisation-de-la-cl-pour-mapper-les-pages">Utilisation de la clé pour mapper les pages</h4><p>Il est parfois utile de connaître la clé utilisé pour la page courante afin de trouver une équivalence dans une autre langue par exemple.</p><p>Avec le webconfig suivant :</p><pre><code class="lang-json">{
    "languageCode": "fr-fr",
    "routes": {
        "index_fr-fr": {
            "url": "/",
            "view": "/index.htm"
        },
        "index_en-us": {
            "url": "/english/",
            "view": "index.htm",
            "languageCode": "en-us"
        },
        "cv_fr-fr": {
            "url": "/cv/",
            "view": "cv.htm"
        },
        "cv_en-us": {
            "url": "/english/resume/",
            "view": "index.htm",
            "languageCode": "en-us"
        }
    }
}
</code></pre><p>et les fichiers de variation commun suivant en fr :</p><pre><code class="lang-json">{
    "language": [{
        "name": "Anglais",
        "code": "en-us"
    }, {
        "name": "Français",
        "code": "fr-fr"
    }]
}
</code></pre><p>et en en :</p><pre><code class="lang-json">{
    "language": [{
        "name": "English",
        "code": "en-us"
    }, {
        "name": "French",
        "code": "fr-fr"
    }]
}
</code></pre><p>on peut alors créer un lien entre chaque page multilingue comme ceci :</p><pre><code class="lang-html"><ul>
    <? for (var i = 0; i < common.language.length; i++) { ?>
    <li><a href="<?= urlBasePath + webconfig.routes[routeKey.split('_')[0] + '_' + common.language[i].code].url ?>"><?- common.language[i].name ?></a></li>
    <? } ?>
</ul>
</code></pre><h3 id="moteur-de-template-personnalise">Moteur de template personnalisé</h3><p>Il est possible de laisser l'implémentation de <a href="http://expressjs.com/fr/guide/using-template-engines.html">Express prendre la main sur le moteur de rendu des vues</a>. Pour cela il faut utiliser le paramètre <code>engine</code>. Un exemple en utilisant le moteur Handlebars :</p><p>Tout d'abord, ajouter le middleware Express Handlebars à vos modules :</p><pre><code>npm install express-handlebars
</code></pre><p>puis utiliser <code>engine</code> avec la valeur arbitraire <code>hbs</code></p><pre><code>{
    "engine": "hbs",
    "controller": "common.js",
    "variation": "common.json",
    "routes": {
        "/": {
            "view": "index.hbs",
            "variation": "index.json"
        }
    }
}
</code></pre><p>puis expliquer au moteur Express de NodeAtlas comment rendre les vues :</p><pre><code class="lang-js">exports.setModules = function () {
    var NA = this;

    NA.modules.exphbs = require("express-handlebars");
};

exports.setConfigurations = function (next) {
  var NA = this,
    exphbs = NA.modules.exphbs;

    NA.express.engine("hbs", exphbs());

    next();
};
</code></pre><p>enfin voyons rapidement ce que le fichier <code>index.hbs</code> pourrait contenir :</p><pre><code class="lang-html"><!DOCTYPE html>
<html lang="fr-fr">
    <head>
        <meta charset="utf-8">
        <title>{{specific.titlePage}}</title>
        <link rel="stylesheet" href="stylesheets/{{common.classCssCommon}}.css" media="all">
        <link rel="stylesheet" href="stylesheets/{{specific.classPage}}.css" media="all">
    </head>
    <body class="{{specific.classPage}}">
        <div>
            <h1>{{specific.titlePage}}</h1>
            {{{specific.content}}}
        </div>
        <script async="true" type="text/javascript" src="javascripts/{{common.classJsCommon}}.js"></script>
    </body>
</html>
</code></pre><p>Ce que fait <code>engine</code>, c'est abandonner le système de NodeAtlas et passer par celui d'Express. Comme Express a besoin d'un objet <code>response</code> pour rendre une vue, il est impossible d'utiliser ce mécanisme via l'utilisation de la fonction <code>NA.view</code> de l'API NodeAtlas, celle-ci ne supportant que le moteur NodeAtlas, EJS et PUG.</p><h4 id="diff-rence-entre-engine-templateenginedelimiter-et-pug-">Différence entre <code>engine</code>, <code>templateEngineDelimiter</code> et <code>pug</code></h4><p>Il est tout a fait possible de passer par Express pour rendre EJS et PUG. Dans ce cas, puisque <code>node-atlas</code> embarque les modules <code>ejs</code> et <code>pug</code> en tant que dépendance, il n'est pas nécéssaire de passer par le <code>controller</code> commun et l'utilisation de <code>npm</code> pour les mettre en place. Il suffit juste d'utiliser <code>engine: "ejs"</code> ou <code>engine: "pug"</code>.</p><p>Cependant, faire cela retire les bénéfices apporter par NodeAtlas pour l'utilisation de ces deux moteurs comme par exemple le support des inclusions dynamique pour PUG dans la <code>view</code> avec <code>#{routeParameters.view}</code>.</p><h3 id="pas-de-vue">Pas de vue</h3><p>Il est possible de ne pas utiliser de vue et de seulement faire appel au contrôleur. Dans ce cas le point d'ancrage <code>changeVariations</code> est inutile. Il va falloir alimenter vous même <code>locals.dom</code> dans le point d'ancrage <code>changeDom</code>.</p><p><em>webconfig.json</em></p><pre><code class="lang-json">{
    "routes": {
        "/(:member/)?": {
            "controller": "index.js",
            "mimeType": "application/json"
        }
    }
}
</code></pre><p><em>controllers/index.js</em></p><pre><code class="lang-js">exports.changeDom = function (next, locals) {
    locals.dom = `{
  "params": ${locals.params.member},
  "query": ${locals.query.member},
  "body": ${locals.body.member}
}`;

    next();
};
</code></pre><p>Ainsi à l'adresse <code>http://localhost/riri/?query=fifi</code> demandé en POST avec le body <code>member=loulou</code> vous obtiendrez la sortie :</p><pre><code class="lang-json">{
  "params": "riri",
  "query": "fifi",
  "body": "loulou"
}
</code></pre><h4 id="pas-de-routes">Pas de routes</h4><p>Pas un seul webconfig présenté dans la documentation ne se passe du paramètre <code>routes</code>. Pourtant il est facultatif au même titre que tous les autres. Aussi avec le Webconfig suivant :</p><p><em>webconfig.json</em></p><pre><code class="lang-json">{
    "controller": "common.js"
}
</code></pre><p>et le contrôleur suivant :</p><p><em>controllers/common.js</em></p><pre><code class="lang-js">exports.setRoutes = function (next) {
    var NA = this,
        route = NA.webconfig.routes = {};

    route["/"] = {
        "mimeType": "text/plain"
    };

    next();
};

exports.changeDom = function (next, locals) {

    locals.dom = "Hello World";

    next();
};
</code></pre><p>Il est tout à fait possible d'obtenir à l'adresse <code>http://localhost/</code> le simple message « Hello World ».</p><h3 id="activer-le-cache">Activer le cache</h3><p>C'est une bonne chose de ne pas reservir des fichiers qui n'ont pas bougé pour la production. Vous pouvez mettre à <code>true</code> la valeur du webconfig <code>cache</code> pour ça:</p><pre><code class="lang-json">{
    cache: true,
    route: {
      "/": "index.htm"
    }
}
</code></pre><p>Vous pouvez également lancer <code>node-atlas</code> avec l'option <code>--cache</code> :</p><blockquote>
<pre><code class="lang-bash">node-atlas --cache
</code></pre>
</blockquote><p>ou mettre votre variable d'environnement <code>NODE_ENV</code> à <code>production</code> :</p><blockquote>
<p>si vous êtes sous Unix/MacOS</p>
<pre><code class="lang-bash">export NODE_ENV=production
</code></pre>
<p>ou si vous êtes sur windows</p>
<pre><code class="lang-bash">SET NODE_ENV=production
</code></pre>
<p>ou vous pouvez démarrer NodeAtlas comme suit</p>
<pre><code class="lang-bash">NODE_ENV=production node-atlas
</code></pre>
<p>ou vous pouvez la définir dans votre fichier JavaScript :</p>
<pre><code class="lang-js">process.env.NODE_ENV = "production";
</code></pre>
</blockquote><div><div class="before">
                            <a href="partie-controleur-et-modele.html">◄ Partie Contrôleur et Modèle</a>
                        </div><div class="after">
                            <a href="anatomie-du-webconfig.html">Anatomie du Webconfig ►</a>
                        </div></div>